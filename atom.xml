<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>djdgctw 的硬件笔记</title>
  
  <subtitle>FPGA · Verilog · HDMI · SpinalHDL</subtitle>
  <link href="https://djdgctw.github.io/atom.xml" rel="self"/>
  
  <link href="https://djdgctw.github.io/"/>
  <updated>2025-11-23T05:52:53.252Z</updated>
  <id>https://djdgctw.github.io/</id>
  
  <author>
    <name>djdgctw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 Python 的 Cocotb 库对 Verilog 进行仿真教程（一）</title>
    <link href="https://djdgctw.github.io/2025/11/23/%E5%9F%BA%E4%BA%8Epython%E7%9A%84cocotb%E5%BA%93%E5%AF%B9verilog%E8%BF%9B%E8%A1%8C%E4%BB%BF%E7%9C%9F%E6%95%99%E7%A8%8B-%E4%B8%80/"/>
    <id>https://djdgctw.github.io/2025/11/23/%E5%9F%BA%E4%BA%8Epython%E7%9A%84cocotb%E5%BA%93%E5%AF%B9verilog%E8%BF%9B%E8%A1%8C%E4%BB%BF%E7%9C%9F%E6%95%99%E7%A8%8B-%E4%B8%80/</id>
    <published>2025-11-23T05:24:27.000Z</published>
    <updated>2025-11-23T05:52:53.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>👉 <a href="https://github.com/djdgctw/first_cocotb_testbench">https://github.com/djdgctw/first_cocotb_testbench</a></p><p>本教程对应仓库的 <code>01_base</code> 示例，是 Verilator × Cocotb 入门的最小可运行工程。</p><h2 id="1-跑通-01-base-基础流程"><a href="#1-跑通-01-base-基础流程" class="headerlink" title="1. 跑通 01_base 基础流程"></a>1. 跑通 01_base 基础流程</h2><p>环境要求：</p><ol><li>Ubuntu（或 WSL2）  </li><li>Verilator（apt 或源码编译均可）  </li><li>Python（conda &#x2F; 系统 Python 均可）  </li><li><code>pip install cocotb</code></li></ol><p>克隆仓库后进入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> first_cocotb_testbench/01_base</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">项目结构如下：</span><br><span class="line"></span><br><span class="line">![01\_base项目结构示意图](/img/01_cocotb/01.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. 示例流程讲解</span></span><br><span class="line"></span><br><span class="line">在 `01_base` 目录下执行：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">make run-logged SIM=verilator</span><br></pre></td></tr></table></figure><p>该命令会：</p><ul><li>调用 cocotb 的 Makefile 体系</li><li>使用 Verilator 对 <code>src/dff.sv</code> 进行编译</li><li>运行 Python 侧的 testbench</li><li>将运行日志与波形存入 <code>logs/</code> 目录（含 <code>report.log</code> 与波形文件）</li></ul><p>Makefile 关键逻辑如下：</p><p><img src="/img/01_cocotb/02.png" alt="makefile部分代码"></p><h2 id="3-原理讲解"><a href="#3-原理讲解" class="headerlink" title="3. 原理讲解"></a>3. 原理讲解</h2><p>本示例由 Verilog 设计文件 <code>dff.sv</code> 与 Python Cocotb 测试文件 <code>test_dff.py</code> 组成，二者通过 cocotb 的 VPI&#x2F;PLI 接口建立交互。</p><h3 id="3-1-Verilog-代码讲解（被测模块-DUT）"><a href="#3-1-Verilog-代码讲解（被测模块-DUT）" class="headerlink" title="3.1 Verilog 代码讲解（被测模块 DUT）"></a>3.1 Verilog 代码讲解（被测模块 DUT）</h3><p>以下是示例中最小 D 触发器：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1us/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> dff (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] q,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>       clk,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] d</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    q &lt;= d;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>上升沿采样：每个 <code>posedge clk</code>，<code>q</code> 都会更新为 <code>d</code></li><li>延迟语义：行为等价于 “q &#x3D; d 上一拍的值”</li></ul><h3 id="3-2-Cocotb-Python-测试代码讲解"><a href="#3-2-Cocotb-Python-测试代码讲解" class="headerlink" title="3.2 Cocotb Python 测试代码讲解"></a>3.2 Cocotb Python 测试代码讲解</h3><p>以下为本示例中的核心测试函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> cocotb</span><br><span class="line"><span class="keyword">from</span> cocotb.clock <span class="keyword">import</span> Clock</span><br><span class="line"><span class="keyword">from</span> cocotb.triggers <span class="keyword">import</span> FallingEdge</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@cocotb.test()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_dff_simple</span>(<span class="params">dut</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;验证 d 能正确传递到 q&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建日志器</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">&quot;my_testbench&quot;</span>)</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 10us 周期的时钟</span></span><br><span class="line">    clock = Clock(dut.clk, <span class="number">10</span>, unit=<span class="string">&quot;us&quot;</span>)</span><br><span class="line">    cocotb.start_soon(clock.start())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行 10 轮随机激励</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        val = random.randint(<span class="number">0</span>, <span class="number">7</span>)</span><br><span class="line">        dut.d.value = val  <span class="comment"># 写入 DUT 输入</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> FallingEdge(dut.clk)  <span class="comment"># 等待一个时钟下降沿</span></span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;周期 <span class="subst">&#123;i&#125;</span>: d=<span class="subst">&#123;dut.d.value&#125;</span>, q=<span class="subst">&#123;dut.q.value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 断言检查（若错误会自动中止测试）</span></span><br><span class="line">        <span class="keyword">assert</span> dut.q.value == val, \</span><br><span class="line">            <span class="string">f&quot;第 <span class="subst">&#123;i&#125;</span> 次检查失败：期望 <span class="subst">&#123;val&#125;</span>，实际 <span class="subst">&#123;dut.q.value&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>重点：</p><ul><li><code>@cocotb.test()</code>：声明 Python 测试用例</li><li><code>Clock(...)</code>：在 Python 侧创建时钟并驱动 DUT</li><li><code>await FallingEdge(...)</code>：事件驱动式仿真</li><li><code>.value</code> 是 cocotb 写入和读取信号的标准方式</li><li>断言错误会直接标红报告</li></ul><h3 id="3-3-Makefile-核心部分解释"><a href="#3-3-Makefile-核心部分解释" class="headerlink" title="3.3 Makefile 核心部分解释"></a>3.3 Makefile 核心部分解释</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testbench 作为 Python 模块路径</span></span><br><span class="line"><span class="keyword">export</span> PYTHONPATH := <span class="variable">$(PWD)</span>/testbench:<span class="variable">$(PYTHONPATH)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定被测模块语言</span></span><br><span class="line">TOPLEVEL_LANG = verilog</span><br><span class="line"></span><br><span class="line"><span class="comment"># DUT 的源文件</span></span><br><span class="line">VERILOG_SOURCES = <span class="variable">$(PWD)</span>/src/dff.sv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顶层模块名</span></span><br><span class="line">TOPLEVEL = dff</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cocotb 的 Python 测试模块名（不带 .py）</span></span><br><span class="line">MODULE = test_dff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认使用 Verilator</span></span><br><span class="line">SIM ?= verilator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入 cocotb 的标准 Makefile</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(<span class="built_in">shell</span> cocotb-config --makefiles)</span>/Makefile.sim</span><br></pre></td></tr></table></figure><p>简要说明：</p><ul><li><code>TOPLEVEL</code> 必须与 Verilog 中的模块名一致</li><li><code>MODULE=test_dff</code> 指定 Python 测试入口</li><li><code>VERILOG_SOURCES</code> 决定参与仿真的 RTL 文件</li><li><code>cocotb-config</code> 自动选择正确的仿真器后端</li></ul><blockquote><p><strong>换模块时，只需改：</strong><br><code>src/*.sv</code>、<code>TOPLEVEL</code>、<code>MODULE</code><br>其余逻辑无需修改。</p></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本篇示例展示了 Cocotb 最小可运行工程的结构和原理，包括：</p><ul><li>Verilator + Cocotb 的协同仿真流程</li><li>Verilog DUT 的构成</li><li>Python 异步 testbench 的写法</li><li>Makefile 如何将两者串联</li></ul><p>在后面篇章中我将逐渐更新：</p><ul><li>如何利用python强大的功能将verilog仿真结果转化为可观看的图片</li><li>如何使得cocotb通过modelsim支持vivado中使用了ip核的仿真</li></ul>]]></content>
    
    
    <summary type="html">基于 Verilator 与 Cocotb 对 Verilog 模块进行协同仿真的基础流程与原理讲解。</summary>
    
    
    
    
    <category term="cocotb" scheme="https://djdgctw.github.io/tags/cocotb/"/>
    
    <category term="verilog" scheme="https://djdgctw.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>KV260 视频链路实验记录：从 ISP 到 HDMI</title>
    <link href="https://djdgctw.github.io/2025/02/20/video-pipeline-lab/"/>
    <id>https://djdgctw.github.io/2025/02/20/video-pipeline-lab/</id>
    <published>2025-02-20T01:30:00.000Z</published>
    <updated>2025-02-20T01:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔记以“模块目标 + 关键寄存器 + 验证方法”记录，方便复现或移植到其他平台。</p></blockquote><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MIPI/RAW Sensor</span><br><span class="line">    ↓ (AXI Stream)</span><br><span class="line">Image Signal Processor (Demosaic + Gamma)</span><br><span class="line">    ↓</span><br><span class="line">AXI VDMA (Write)</span><br><span class="line">    ↓</span><br><span class="line">DDR 圆形缓冲</span><br><span class="line">    ↓</span><br><span class="line">AXI VDMA (Read)</span><br><span class="line">    ↓</span><br><span class="line">Video Mixer (OSD + Scaling)</span><br><span class="line">    ↓</span><br><span class="line">HDMI TX Subsystem</span><br></pre></td></tr></table></figure><p>核心是把 ISP 与 HDMI TX 解耦，通过 VDMA 做帧缓存，调试时可以单独验证每个 Stage。</p><h2 id="2-Sensor-ISP"><a href="#2-Sensor-ISP" class="headerlink" title="2. Sensor &amp; ISP"></a>2. Sensor &amp; ISP</h2><ul><li>选择 <code>imx219</code> 作为 RAW 输入，MIPI 配置脚本使用 <code>i2cset</code> 写寄存器，注意 <code>0x0157</code> 需设置为正确的 <code>line_length_pck</code>。</li><li>ISP 只开启 Demosaic + Gamma，关闭变焦模块以减少延迟。</li><li>用 <code>v4l2-ctl --stream-mmap --stream-to=/dev/null --stream-count=200</code> 先确认 Sensor 输出稳定。</li></ul><h2 id="3-VDMA-的关键寄存器"><a href="#3-VDMA-的关键寄存器" class="headerlink" title="3. VDMA 的关键寄存器"></a>3. VDMA 的关键寄存器</h2><table><thead><tr><th>寄存器</th><th>作用</th><th>经验值</th></tr></thead><tbody><tr><td><code>MM2S_VSIZE</code></td><td>行数</td><td>1080</td></tr><tr><td><code>MM2S_HSIZE</code></td><td>单行字节数</td><td>3840 (1920×2B)</td></tr><tr><td><code>FRMDLY_STRIDE</code></td><td>行间距</td><td>4096, 对齐 4KB</td></tr></tbody></table><p>Tips：KV260 上 DDR 通常配置为 32bit AXI，总线利用率不够时，可以把 <code>HSIZE</code> 扩充到 4096 字节来做突发。</p><h2 id="4-调试脚本"><a href="#4-调试脚本" class="headerlink" title="4. 调试脚本"></a>4. 调试脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写通 Sensor → ISP → VDMA</span></span><br><span class="line"><span class="built_in">sudo</span> modprobe xlnx-isp</span><br><span class="line"><span class="built_in">sudo</span> modprobe xilinx-vdma</span><br><span class="line"></span><br><span class="line">media-ctl -d /dev/media0 -l <span class="string">&quot;&#x27;mipi_csi2 0&#x27;:1 -&gt; &#x27;xilinx-video 0&#x27;:0 [1]&quot;</span></span><br><span class="line">media-ctl -d /dev/media0 -V <span class="string">&quot;&#x27;mipi_csi2 0&#x27;:1 [fmt:SRGGB10_1X10/1920x1080@1/30]&quot;</span></span><br><span class="line"></span><br><span class="line">vdma_ctl write start --width 1920 --height 1080 --<span class="built_in">fmt</span> rgb</span><br></pre></td></tr></table></figure><h2 id="5-HDMI-输出"><a href="#5-HDMI-输出" class="headerlink" title="5. HDMI 输出"></a>5. HDMI 输出</h2><ul><li>HDMI TX Subsystem 选择 148.5 MHz, Color Depth 8bit，勾选内置 InfoFrame 生成器。</li><li>如果屏幕黑屏，优先检查 <code>HPD</code> 是否拉高、EDID 读取是否成功（<code>cat /sys/kernel/debug/dri/0/i915_edid_raw</code>）。</li><li>用 <code>xilinx-axidma</code> 工具注入彩条数据，可以验证链路是否正确。</li></ul><h2 id="6-待办"><a href="#6-待办" class="headerlink" title="6. 待办"></a>6. 待办</h2><ul><li><input disabled="" type="checkbox"> 增加 HDR 元数据通路</li><li><input disabled="" type="checkbox"> 编写自动化 bring-up 脚本，整合到 <code>make video-demo</code></li><li><input disabled="" type="checkbox"> 测试两路 PIP 输出</li></ul><p>有问题欢迎在评论区一起讨论。</p>]]></content>
    
    
    <summary type="html">用 KV260 打通 RAW Sensor → ISP → 视频缓存 → HDMI 输出的链路，并记录调试步骤与可复用的脚本。</summary>
    
    
    
    <category term="Lab Notes" scheme="https://djdgctw.github.io/categories/Lab-Notes/"/>
    
    
    <category term="HDMI" scheme="https://djdgctw.github.io/tags/HDMI/"/>
    
    <category term="KV260" scheme="https://djdgctw.github.io/tags/KV260/"/>
    
    <category term="视频链路" scheme="https://djdgctw.github.io/tags/%E8%A7%86%E9%A2%91%E9%93%BE%E8%B7%AF/"/>
    
    <category term="实验记录" scheme="https://djdgctw.github.io/tags/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>HDMI 1.4 协议总结（一）：综述和编码方式</title>
    <link href="https://djdgctw.github.io/2025/02/15/hello-world/"/>
    <id>https://djdgctw.github.io/2025/02/15/hello-world/</id>
    <published>2025-02-15T02:00:00.000Z</published>
    <updated>2025-02-15T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做协议学习笔记时，我喜欢按照“迭代脉络 → 物理层 → 编码 → 状态机”的顺序去拆，所有细节都能挂在这个主线下。</p></blockquote><h2 id="1-版本演进与应用场景"><a href="#1-版本演进与应用场景" class="headerlink" title="1. 版本演进与应用场景"></a>1. 版本演进与应用场景</h2><ul><li><strong>HDMI 1.3 → 1.4</strong>：最关键的变化是速率从 2.25 Gbps 提升到了 3.4 Gbps，随后带来了 4K@30Hz、3D、以太网通道 (HEC) 等新功能。</li><li><strong>接口形式</strong>：Type A&#x2F;B（经典）、Type C（Mini）、Type D（Micro），Type E 专供汽车电子。硬件设计要关注 crosstalk 与 EMI 预算。</li><li><strong>时钟参考</strong>：TMDS Clock 最大 340 MHz。对 FPGA 来说意味着 PLL 需要支持 742.5 MHz 以上的高速串并转换（8&#x2F;10bit）。</li></ul><h2 id="2-TMDS-信号链"><a href="#2-TMDS-信号链" class="headerlink" title="2. TMDS 信号链"></a>2. TMDS 信号链</h2><p>HDMI 的三条数据通道和一条时钟通道共享同一组差分对。数据链路遵循 TMDS（Transition Minimized Differential Signaling）编码：</p><ol><li><strong>预处理</strong>：像素数据按 R&#x2F;G&#x2F;B 通道送入，控制期 (HBlank&#x2F;VBlank) 由 <code>CTL[3:0]</code> 置位。</li><li><strong>8b&#x2F;10b</strong>：先做 XOR&#x2F;XNOR 降低翻转次数，再根据 DC 平衡选择 <code>q_m</code> 的极性，最后串化成 10bit。</li><li><strong>序列化</strong>：常见做法是 OSERDES ×2 级联，时钟倍频 5 倍后 DDR 输出。</li><li><strong>传输层</strong>：差分对阻抗 100 Ω，常见布局要求 5 mil 线宽、对内注入 GND Guard。板级 EMI 控制在 3 Gbps 以上尤为重要。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  A(Pixel Bus) --&gt; B[TMDS Encoder]</span><br><span class="line">  B --&gt; C&#123;DC Balance&#125;</span><br><span class="line">  C --&gt;|10bit| D[Serializer]</span><br><span class="line">  D --&gt; E(TMDS Pair)</span><br></pre></td></tr></table></figure><h2 id="3-控制期编码"><a href="#3-控制期编码" class="headerlink" title="3. 控制期编码"></a>3. 控制期编码</h2><p>在消隐阶段，TMDS 数据通道不再传输像素，而是携带帧同步信息。表格是我在阅读标准时整理的速查版本：</p><table><thead><tr><th>CTL[3:0]</th><th>意义</th><th>通道数据</th></tr></thead><tbody><tr><td><code>0001</code></td><td>HSYNC 有效</td><td>CH0 发送 <code>1011001100</code></td></tr><tr><td><code>0010</code></td><td>VSYNC 有效</td><td>CH1 发送 <code>1011001100</code></td></tr><tr><td><code>0011</code></td><td>同时有效</td><td>CH2 发送 <code>1011001100</code></td></tr><tr><td>其他</td><td>保留</td><td>发送 <code>0100110011</code></td></tr></tbody></table><p>多数字库会把这些模式烧在 ROM 里，自己实现时记得考虑 pipeline 的气泡管理。</p><h2 id="4-工程实践-Tips"><a href="#4-工程实践-Tips" class="headerlink" title="4. 工程实践 Tips"></a>4. 工程实践 Tips</h2><ol><li><strong>像素域与 TMDS 域</strong>：强烈建议用 <code>pixel_clk</code> 做同步逻辑，再通过 <code>BUFPLL/OSERDES</code> 将 TMDS 域隔离，跨域只传控制字。</li><li><strong>ILA 观测</strong>：抓取 10bit TMDS 码字能帮助快速定位出错 Stage。若 DC balance 震荡，意味着 XOR&#x2F;XNOR 选择错了。</li><li><strong>前向纠错</strong>：HDMI 1.4 仍旧没有 FEC，链路稳定性高度依赖布线与器件，量产要考虑眼图测试。</li><li><strong>带宽预算</strong>：4K@30Hz RGB444 需要 297 MHz 像素时钟；8&#x2F;10bit 之后每通道 2.97 Gbps，留足 20% 裕量。</li></ol><p>下一篇会继续写 <code>InfoFrame</code>、EDID、HDCP 1.4 握手，欢迎一起交流。</p>]]></content>
    
    
    <summary type="html">梳理 HDMI 1.4 的版本脉络、速率规格以及关键的 TMDS 编码流程，帮助快速回忆链路设计要点。</summary>
    
    
    
    <category term="接口协议" scheme="https://djdgctw.github.io/categories/%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HDMI" scheme="https://djdgctw.github.io/tags/HDMI/"/>
    
    <category term="TMDS" scheme="https://djdgctw.github.io/tags/TMDS/"/>
    
    <category term="视频接口" scheme="https://djdgctw.github.io/tags/%E8%A7%86%E9%A2%91%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>SpinalHDL Stream 小抄：5 个提升流水线可读性的技巧</title>
    <link href="https://djdgctw.github.io/2025/02/10/spinalhdl-stream-cheatsheet/"/>
    <id>https://djdgctw.github.io/2025/02/10/spinalhdl-stream-cheatsheet/</id>
    <published>2025-02-10T13:30:00.000Z</published>
    <updated>2025-02-18T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpinalHDL 的 <code>Stream</code>&#x2F;<code>Flow</code> 是数据路径的基石，语法简单但很容易写成“神秘黑盒”。这篇整理了几个最常用的技巧。</p><h2 id="1-约定式命名"><a href="#1-约定式命名" class="headerlink" title="1. 约定式命名"></a>1. 约定式命名</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pixIn  = slave <span class="type">Stream</span>(<span class="type">Pixel</span>())</span><br><span class="line"><span class="keyword">val</span> pixOut = master <span class="type">Stream</span>(<span class="type">Pixel</span>())</span><br></pre></td></tr></table></figure><p>把 <code>Stream</code> 当作“业务数据 + 握手”的整体来命名，避免 <code>data</code>, <code>valid</code> 分家导致重复连线。</p><h2 id="2-与"><a href="#2-与" class="headerlink" title="2. &gt;&gt; 与 &lt;&lt; 的用法"></a>2. <code>&gt;&gt;</code> 与 <code>&lt;&lt;</code> 的用法</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixOut &lt;&lt; pixIn.throwWhen(dropLine)</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;</code> 会自动帮我们连接 <code>valid/ready</code>. 当需要对 <code>payload</code> 做操作时，记得使用 <code>.translateWith</code>，否则 <code>valid</code> 和 <code>payload</code> 的时序会错位。</p><h2 id="3-管线化方法"><a href="#3-管线化方法" class="headerlink" title="3. 管线化方法"></a>3. 管线化方法</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stage2 = pixIn.m2sPipe()</span><br><span class="line"><span class="keyword">val</span> stage3 = stage2.queue(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ul><li><code>m2sPipe</code>: 只寄存 <code>payload</code></li><li><code>s2mPipe</code>: 只寄存反压</li><li><code>queue</code>: 带深度的 FIFO，可选 <code>pipeline</code>, <code>flow</code>, <code>stream</code> 模式</li></ul><p>组合使用能够更严格地控制延迟。</p><h2 id="4-调试：用-StreamMonitor"><a href="#4-调试：用-StreamMonitor" class="headerlink" title="4. 调试：用 StreamMonitor"></a>4. 调试：用 <code>StreamMonitor</code></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamMonitor</span>(pixOut)&#123; packet =&gt;</span><br><span class="line">  assert(packet.payload.alpha &lt;= <span class="number">255</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搭配 <code>SimTimeout</code>, <code>SimClockDomain</code> 可以快速定位 handshake carding。尤其在视频项目里，一旦 <code>ready</code> 被拉低，整帧都会“褪色”，必须第一时间定位。</p><h2 id="5-与-AXI4-Stream-的互操作"><a href="#5-与-AXI4-Stream-的互操作" class="headerlink" title="5. 与 AXI4-Stream 的互操作"></a>5. 与 AXI4-Stream 的互操作</h2><p>SpinalHDL 提供 <code>Axi4Stream</code> 封装，实际上就是 <code>Stream(Fragment(Bits()))</code>。常见的桥接写法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> axis = master <span class="type">Axi4Stream</span>(axiConfig)</span><br><span class="line"><span class="keyword">val</span> pix  = slave <span class="type">Stream</span>(<span class="type">Fragment</span>(<span class="type">Pixel</span>()))</span><br><span class="line"></span><br><span class="line">axis.payload.fragment := pix.payload.fragment.asBits</span><br><span class="line">axis.last              := pix.last</span><br><span class="line">pix.ready              := axis.ready</span><br></pre></td></tr></table></figure><h2 id="Checklist"><a href="#Checklist" class="headerlink" title="Checklist"></a>Checklist</h2><ul><li><input checked="" disabled="" type="checkbox"> 统一使用 <code>Stream</code> 命名</li><li><input checked="" disabled="" type="checkbox"> 加上 <code>queue</code>&#x2F;<code>pipe</code> 注释延迟</li><li><input disabled="" type="checkbox"> 整理一个可复用的 <code>StreamBus</code> trait</li></ul><p>希望这份小抄能帮你写出更优雅的流水线模块。</p>]]></content>
    
    
    <summary type="html">记录在视频链路项目里使用 SpinalHDL Stream 接口时积累的模式，从命名到仿真都覆盖。</summary>
    
    
    
    <category term="FPGA" scheme="https://djdgctw.github.io/categories/FPGA/"/>
    
    
    <category term="SpinalHDL" scheme="https://djdgctw.github.io/tags/SpinalHDL/"/>
    
    <category term="Scala" scheme="https://djdgctw.github.io/tags/Scala/"/>
    
    <category term="流水线" scheme="https://djdgctw.github.io/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    
    <category term="笔记" scheme="https://djdgctw.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
